/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package view;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import model.pila;
import static model.reader.esEntero;
import static model.reader.leerArchivo;


/* @author Ailer Alvarado - Armando Arce - Daniel Rojas*/
public class MainGUI extends javax.swing.JFrame {
    private static int n_memoria = 256;
    private static int n_pila = 10;
    private static List<String>[] memoria = new ArrayList[n_memoria];
    private static List<String>[] pila = new ArrayList[n_pila];
    private static HashMap<String, Integer> registros_valores = new HashMap<String, Integer>() {{
        put("AC", 0); put("AX", 0); put("BX", 0); put("CX", 0); put("DX", 0);
    }};
    private static final HashMap<String, String> operaciones = new HashMap<String, String>() {{
        put("LOAD", "0001"); put("STORE", "0010"); put("SUB", "0100"); put("ADD", "0101");
    }};
    private static final HashMap<String, String> registros = new HashMap<String, String>() {{
        put("AX", "0001"); put("BX", "0010"); put("CX", "0011"); put("DX", "0100");
    }};
    static pila la_pila = new pila();
    static boolean bandera_cmp = false;
    
    /*** Creates new form MainGUI */
    public MainGUI() {
        try { // Cambiar el LookAndFeel a Windows
            UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
            System.err.println("Error al cambiar el tema: " + ex.getMessage());
        }
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        sp_tabla = new javax.swing.JScrollPane();
        tabla = new javax.swing.JTable();
        menubar = new javax.swing.JMenuBar();
        menu = new javax.swing.JMenu();
        menu_open = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Tarea 1");
        setLocation(new java.awt.Point(0, 0));
        setMaximumSize(new java.awt.Dimension(1280, 720));
        setMinimumSize(new java.awt.Dimension(640, 480));
        setSize(new java.awt.Dimension(640, 480));

        sp_tabla.setEnabled(false);
        sp_tabla.setFocusable(false);

        tabla.getTableHeader().setReorderingAllowed(false); // Evitar que el usuario mueva las columnas
        tabla.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "CODIGO ASM", "COD BINARIO", "AC", "AX", "BX", "CX", "DX"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tabla.setColumnSelectionAllowed(true);
        tabla.setEnabled(false);
        sp_tabla.setViewportView(tabla);

        menu.setText("File");

        menu_open.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        menu_open.setText("Open");
        menu_open.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menu_openActionPerformed(evt);
            }
        });
        menu.add(menu_open);

        menubar.add(menu);

        setJMenuBar(menubar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(sp_tabla, javax.swing.GroupLayout.DEFAULT_SIZE, 628, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(sp_tabla, javax.swing.GroupLayout.DEFAULT_SIZE, 436, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * Toma el valor del registro especificado por "registro_por_tomar" y lo asigna a "AC".
     * @param registro_por_tomar el registro del cual se tomará el valor a asignar a "AC".
     */
    public static void load(String registro_por_tomar) {
        int valor_por_tomar = registros_valores.get(registro_por_tomar);
        registros_valores.put("AC", valor_por_tomar);
    }

    /**
    * Toma el valor actual en "AC" y lo asigna al registro especificado por "registro_por_actualizar".
    * @param registro_por_actualizar el registro al cual se le asignará el valor actual en "AC".
    */
    public static void store(String registro_por_actualizar) {
        registros_valores.put(registro_por_actualizar, registros_valores.get("AC"));
    }
    
    /**
     * Asigna el valor dado por valor_asignado al registro dado por reg_destino
     * @param reg_destino el registro al cual se le asignará un nuevo valor.
     * @param valor_asignado el valor que se asignará al registro especificado.
     */
    public static void mov_valor(String reg_destino, Integer valor_asignado) {
        registros_valores.put(reg_destino, valor_asignado);
    }
      
    /**
     * Asigna el valor tomado del registro reg_origen al registro dado por reg_destino
     * @param reg_destino el registro al cual se le asignará un nuevo valor.
     * @param reg_origen el registro del que se tomara el valor por asignar.
     */
    public static void mov_reg(String reg_destino, String reg_origen) {
        registros_valores.put(reg_destino, registros_valores.get(reg_origen));
    }
    
    /**
     * Toma el valor del registro especificado por "registro_a_sumar" y lo suma al valor actual en "AC".
     * @param registro_a_sumar el registro cuyo valor se sumará al valor actual en "AC".
     */
    public static void add(String registro_a_sumar) {
        int valor_a_sumar = registros_valores.get(registro_a_sumar);
        int nuevo_valor = registros_valores.get("AC") + valor_a_sumar;
        registros_valores.put("AC", nuevo_valor);
    }

    /**
     * Toma el valor del registro especificado por "registro_a_restar" y lo resta al valor actual en "AC".
     * @param registro_a_restar el registro cuyo valor se restará al valor actual en "AC".
     */
    public static void sub(String registro_a_restar) {
        int valor_a_restar = registros_valores.get(registro_a_restar);
        int nuevo_valor = registros_valores.get("AC") - valor_a_restar;
        registros_valores.put("AC", nuevo_valor);
    }

    /**
     * Incrementa el valor dado por registro_a_incrementar
     * @param registro_a_incrementar el registro a incrementar
     */
    public static void inc(String registro_a_incrementar) {
        int nuevo_valor = registros_valores.get(registro_a_incrementar) + 1;
        registros_valores.put(registro_a_incrementar, nuevo_valor);
    }
    
    /**
     * Incrementa el valor al registro AC
     */
    public static void inc(){
        inc("AC");
    }
    
    /**
     * Decrementa el valor dado por registro_a_decrementar
     * @param registro_a_decrementar el registro a decrementar
     */
    public static void dec(String registro_a_decrementar) {
        int nuevo_valor = registros_valores.get(registro_a_decrementar) - 1;
        registros_valores.put(registro_a_decrementar, nuevo_valor);
    }
    
    /**
     * Decrementa el valor al registro AC
     */
    public static void dec(){
        dec("AC");
    }
    
    /**
     * Intercambia los valores entre registro_1 y registro_2
     */
    public static void swap(String registro_1, String registro_2) {
        int t_registro_1 = registros_valores.get(registro_1);
        int t_registro_2 = registros_valores.get(registro_2);
        registros_valores.put(registro_1, t_registro_2);
        registros_valores.put(registro_2, t_registro_1);
    }

    /**
     * Guarda en pila el valor del registro especificado por el parámetro 'registro_a_tomar'.
     * @param registro_a_tomar El nombre del registro cuyo valor se debe guardar en pila.
     */
    public static void push(String registro_a_tomar){
        la_pila.push(registros_valores.get(registro_a_tomar));
    }
    /**
     * Almacena un valor entero en la pila.
     * @param valor_por_almacenar El valor entero a almacenar en la pila.
     */
    public static void push_value(String valor_por_almacenar){
        la_pila.push(Integer.valueOf(valor_por_almacenar));
    }
    
    /**
     * Saca el valor de la pila y lo almacena en reg_destino
     * @param reg_destino registro en el que se almacena el valor de la pila
     */
    public static void pop(String reg_destino){
        registros_valores.put(reg_destino, la_pila.pop());
    }
    
    /**
     * Este método solicita al usuario ingresar un valor numérico entre 0 y 255 para el registro DX.
     * Si el usuario ingresa un valor numérico válido, lo almacena en el registro DX a través del método mov_valor().
     * Si el usuario ingresa un valor no numérico, muestra un mensaje de error
     * Si el usuario ingresa un valor numérico fuera del rango válido, muestra un mensaje de error.
     */
    public static void int09() {
        Scanner scanner = new Scanner(System.in);
        String input;
        int value;
        System.out.println("Ingrese un valor numérico entre 0 y 255 para DX: ");
        input = scanner.nextLine();

        try {
            value = Integer.parseInt(input);
            if (value >= 0 && value <= 255) {
                mov_valor("DX", value);
                System.out.println("El valor ingresado es: " + value);
            }
            else {
                System.out.println("Error: debe ingresar un valor entre 0 y 255.");
            }
        } catch (NumberFormatException e) {
            System.out.println("Error: debe ingresar un valor numérico entre 0-255.");
        }
        scanner.close();
    }

    /**
     * Compara dos valores almacenados en registros y establece 
     *  una variable de bandera según el resultado de la comparación.
     * @param registro_1 El nombre del primer registro a comparar.
     * @param registro_2 El nombre del segundo registro a comparar.
     */
    public static void cmp(String registro_1, String registro_2) {
        bandera_cmp = registros_valores.get(registro_1) == registros_valores.get(registro_2);
    }
    
    /* ---------------------------------------------------------------------- */
    /**
    * Convierte un número entero en su representación binaria de 8 bits,
    * teniendo en cuenta el signo del número.
    * @param num El número entero a convertir.
    * @return La representación binaria de 8 bits del número.
    */
    public static String intToBinary8(int num) {
        String binaryString = Integer.toBinaryString(Math.abs(num)); // convertir el valor absoluto a binario
        binaryString = String.format("%8s", binaryString).replace(' ', '0'); // completar con ceros a la izquierda
        if (num < 0) { // si el número es negativo, cambiar el bit de signo
            binaryString = "1" + binaryString.substring(1);
        } else {
            binaryString = "0" + binaryString.substring(1);
        }
        return binaryString;
    }

    /**
     * Toma una lista de cadenas de una línea de código y usa un mapa de operaciones y un mapa de registros ya definidos, 
     * y devuelve una cadena que representa la línea de código en binario.
     * 
     * @param linea La lista de cadenas que representa la línea de código a parsear.
     * @return Una cadena que representa la línea de código en binario.
     */
    public static String parseLine(List<String> linea) {
        String operador = linea.get(0);
        String registro = linea.get(1);
        String valor = "00000000";
        if (linea.size() == 3) {
            int numero = Integer.parseInt(linea.get(2));
            valor = intToBinary8(numero);
        }
        String codigo = operaciones.get(operador);
        String registroBin = registros.get(registro);
        return codigo + " " + registroBin + " " + valor;
    }

    /**
    * Busca un segmento de memoria no utilizado de n líneas consecutivas, 
    * empezando por el índice inicial especificado.
    * 
    * @param indiceInicial El índice inicial a partir del cual buscar.
    * @return Un array de dos elementos que contiene el índice inicial y 
    * final del segmento encontrado, o un array con [-1, -1] si no se encontró ninguno.
    */
    private static int[] buscarSegmentoUsado(int indiceInicial) {
        int indiceActual = indiceInicial;
        while (indiceActual < memoria.length && memoria[indiceActual].isEmpty()) {
            indiceActual++;
        }
        if (indiceActual == memoria.length) {
            // No se encontró ningún segmento con información
            return new int[] {-1, -1};
        }
        // Se encontró un segmento con información
        int indiceFinal = indiceActual;
        while (indiceFinal < memoria.length && !memoria[indiceFinal].isEmpty()) {
            indiceFinal++;
        }
        return new int[] {indiceActual, indiceFinal-1};
    }

    /**
    * Verifica si alguna de las listas en memoria_a_verificar contiene elementos.
    *
    * @param memoria_a_verificar Una lista de listas de strings que representa la memoria a verificar.
    * @return Verdadero si al menos una de las listas contiene elementos, falso de lo contrario.
    */
    private boolean tieneDatos(List<String>[] memoria_a_verificar){
        for (List<String> l: memoria_a_verificar){
            if (!l.isEmpty()) return true;
        }
        return false;
    }

    private void menu_openActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menu_openActionPerformed
        boolean flag_continuar = true;
        JFileChooser chooser = new JFileChooser();
        if (tabla.getModel().getRowCount()!=0){
            int respuesta = JOptionPane.showConfirmDialog(null, "Ya existe un archivo cargado exitosamente\n¿Está seguro de que desea continuar?", "Confirmación", JOptionPane.YES_NO_OPTION);
            flag_continuar = respuesta == JOptionPane.YES_OPTION;
        }
        
        if (flag_continuar){
            chooser.setCurrentDirectory(new File(System.getProperty("user.home") + "/Desktop"));
            chooser.setAcceptAllFileFilterUsed(false); // Deshabilitar el filtro predeterminado
            FileNameExtensionFilter filter = new FileNameExtensionFilter("Archivos ASM", "asm");
            chooser.setFileFilter(filter);
            int result = chooser.showOpenDialog(null);
            if (result == JFileChooser.APPROVE_OPTION) {
                String path = chooser.getSelectedFile().getPath();
                System.out.println("Archivo seleccionado: \n\t" + path);
                try{
                    List<String>[] temp_memoria = memoria.clone(); // Clonamos memoria a una memoria temporal
                temp_memoria = leerArchivo(path, temp_memoria, true); // Se lee arhivo y se asigna a la memoria temporal
                
                if (memoria != temp_memoria && tieneDatos(temp_memoria)) { // Se verifica que las memorias sean diferentes y no esten vacias
                    memoria = temp_memoria.clone();
                    int[] segmentoUsado = buscarSegmentoUsado(10);
                    registros_valores = new HashMap<String, Integer>() {{ // Limpeamos memoria
                            put("AC", 0);
                            put("AX", 0);
                            put("BX", 0);
                            put("CX", 0);
                            put("DX", 0);
                    }};

                    DefaultTableModel modelo = (DefaultTableModel) tabla.getModel();
                    modelo.setNumRows(0);
                    
                    // desde aca es el ejecutar
                    
                    boolean interrupcion_dada = false;
                    for (int i = segmentoUsado[0]; i < segmentoUsado[1]+1; i++) {
                        //=System.out.println(i + " : " + memoria[i]);// Imprime la memoria 
                        if (interrupcion_dada){
                            break;
                        }
                        String temp_cod_asm = memoria[i].get(0);
                        if (memoria[i].size() != 1){
                            temp_cod_asm += " " + memoria[i].get(1);    
                        }
                        switch (memoria[i].get(0)){
                            case "MOV":
                                temp_cod_asm += ", " + memoria[i].get(2);
                                if (esEntero(memoria[i].get(2))){
                                    mov_valor(memoria[i].get(1), Integer.valueOf(memoria[i].get(2)));
                                } else {
                                    mov_reg(memoria[i].get(1), memoria[i].get(2));
                                }
                                break;
                            case "LOAD":
                                load(memoria[i].get(1));
                                break;
                            case "STORE":
                                store(memoria[i].get(1));
                                break;
                            case "ADD":
                                add(memoria[i].get(1));
                                break;
                            case "SUB":
                                sub(memoria[i].get(1));
                                break;
                            case "INC":
                                if (memoria[i].size() == 1){
                                    inc();
                                } else {
                                    inc(memoria[i].get(1));
                                    temp_cod_asm += " " + memoria[i].get(1);
                                }
                                break;
                            case "DEC":
                                if (memoria[i].size() == 1){
                                    dec();
                                } else {
                                    dec(memoria[i].get(1));
                                    temp_cod_asm += " " + memoria[i].get(1);
                                }
                                break;
                            case "SWAP":
                                swap(memoria[i].get(1), memoria[i].get(2));
                                temp_cod_asm += ", " + memoria[i].get(2);
                                break;
                            case "INT":
                                switch (memoria[i].get(1)) {
                                    case "20H": // Finaliza el programa 
                                        interrupcion_dada = true;
                                        break;
                                    case "10H": // Imprime en pantalla el valor del DX 
                                        break;
                                    case "09H": // Entrada del teclado (solo numérico 0-255), el valor se guarda en el DX, finaliza con un ENTER
                                        int09();
                                        break;
                                    case "21H": // Será utilizado para manejo de archivos.
                                        break;
                                    case "3CH":
                                        // Manejar la interrupción 3CH
                                        // ...
                                        break;
                                    case "3DH":
                                        // Manejar la interrupción 3DH
                                        // ...
                                        break;
                                    case "4DH":
                                        // Manejar la interrupción 4DH
                                        // ...
                                        break;
                                    case "40H":
                                        // Manejar la interrupción 40H
                                        // ...
                                        break;
                                    case "41H":
                                        // Manejar la interrupción 41H
                                        // ...
                                        break;
                                }
                                break;
                            case "CMP":
                                cmp(memoria[i].get(1), memoria[i].get(2));
                                temp_cod_asm += ", " + memoria[i].get(2);
                                System.out.println("Bandera : " + bandera_cmp); // borrar
                                break;
                            case "PUSH":
                                push(memoria[i].get(1));
                                System.out.println("Estado de pila: ");  // borrar
                                la_pila.imprimirValores(); // borrar
                                break;
                            case "POP":
                                pop(memoria[i].get(1));
                                System.out.println("Estado de pila: ");  // borrar
                                la_pila.imprimirValores(); // borrar
                                break;
                            case "JMP":
                                System.out.println("Salto de : " + memoria[i].get(1));  // borrar
                                break;
                            case "JE":
                                if (bandera_cmp){
                                    System.out.println("Salto de : " + memoria[i].get(1));  // borrar
                                } else {
                                    System.out.println("Salto no efectuado, el cmp es False");  // borrar
                                }
                                break;
                            case "JNE":
                                if (!bandera_cmp){
                                    System.out.println("Salto no efectuado, el cmp es True");  // borrar
                                }
                                break;
                            case "PARAM":
                                for (int contador = 1; contador < memoria[i].size(); contador++){
                                    push_value(memoria[i].get(contador));
                                    
                                    System.out.println("Estado de pila: ");  // borrar
                                    la_pila.imprimirValores(); // borrar
                                    temp_cod_asm += ", " + memoria[i].get(contador);
                                }
                                break;
                        }
                        
                        modelo.addRow(new Object[] {
                            temp_cod_asm,                   // ASM
                            "0000",//parseLine(memoria[i]),          // Binario
                            registros_valores.get("AC"),    // AC | AX | BX
                            registros_valores.get("AX"),    // AX
                            registros_valores.get("BX"),    // BX
                            registros_valores.get("CX"),    // CX
                            registros_valores.get("DX")     // DX
                        });
                    }
                    tabla.setModel(modelo);
                }
                }catch(Exception e) {
                    System.out.println(e);
                }
                
            }
        }
    }//GEN-LAST:event_menu_openActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        /* Create and display the form */
        for (int i = 0; i < memoria.length; i++) { memoria[i] = new ArrayList<>(); } // Limpeamos la memoria
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MainGUI().setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu menu;
    private javax.swing.JMenuItem menu_open;
    private javax.swing.JMenuBar menubar;
    private javax.swing.JScrollPane sp_tabla;
    private javax.swing.JTable tabla;
    // End of variables declaration//GEN-END:variables
}

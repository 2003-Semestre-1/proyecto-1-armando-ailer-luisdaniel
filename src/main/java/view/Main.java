/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package view;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dialog;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.filechooser.FileNameExtensionFilter;
import model.pila;
import static model.reader.esEntero;
import static model.reader.leerArchivo;
import model.terminal;

/**
 *
 * @author ldani
 */
public class Main extends javax.swing.JFrame {
    private static terminal terminal = new terminal();
    private static final int[] valores_defecto = {256,64,512,10};
    private static int n_memoria = 256;
    private static int n_virtual = 64;
    private static int n_almacenamiento = 512;
    private static int n_pila = 10;
    
    private static List<String>[] memoria = new ArrayList[n_memoria];
    
    private static HashMap<String, Integer> registros_valores = new HashMap<String, Integer>() {{
        put("AC", 0); put("AX", 0); put("BX", 0); put("CX", 0); put("DX", 0);
    }};
    static pila la_pila = new pila(n_pila);
    static boolean bandera_cmp = false;
    static boolean bandera_interrupcion = false;
    private boolean bandera_error = false;
    private static boolean archivo_cargado1 = false;
    private static boolean archivo_cargado2 = false;
    private int siguienteInstruccion = 0;
    private boolean esperando = false;
    private boolean[] estado_botones = new boolean[6];
    private boolean[] estado_botones_paso = new boolean[6];
    private boolean bandera_paso = false;
    
    /**
     * Creates new form Main
     */
    public Main() {
        limpearMemoria();
        initComponents();
        
        setButton(false, bEjecutar);
        setButton(false, bPaso); 
        setButton(false, bEstadistica);
        setButton(false, bSiguiente);
        Component[] componentes = this.getComponents();
        
        
        terminal.getInputField().addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                String input = terminal.getInputField().getText();
                terminal.setLastInput(input);
                terminal.getInputField().setText("");
                terminal.addToOuput(input + "\n> ");
                if (esperando){
                    try {
                        int value = Integer.parseInt(input);
                        if (value >= 0 && value <= 255) {
                            mov_valor("DX", value);
                            cambiarEstadoComponentes(true);
                            setEstadoBotones(estado_botones);
                            if (bandera_paso){
                                bSiguienteActionPerformed(null);
                            } else{
                                bEjecutarActionPerformed(null);
                            }
                            terminal.setEsperando(false);
                        } else {
                            terminal.addToOuput("Error: debe ingresar un valor numérico entre 0~255. \n> Ingrese nuevamente un valor: ");
                        }
                    } catch (NumberFormatException ex) {
                        terminal.addToOuput("Error: debe ingresar un valor numérico entre 0~255. \n> Ingrese nuevamente un valor: ");
                    }
                }
            }
        });
        upperRightPanel.add(terminal);
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        configDialog = new javax.swing.JDialog();
        labMemoria = new javax.swing.JLabel();
        labMemoriaVirtual = new javax.swing.JLabel();
        labPila = new javax.swing.JLabel();
        labAlmacenamiento = new javax.swing.JLabel();
        memoriaTextField = new javax.swing.JTextField();
        almacenamientoTextField = new javax.swing.JTextField();
        virtualTextField = new javax.swing.JTextField();
        pilaTextField = new javax.swing.JTextField();
        bGuardarConf = new javax.swing.JButton();
        bRestablecer = new javax.swing.JButton();
        lowerPanel = new javax.swing.JPanel();
        pCPU1 = new javax.swing.JPanel();
        spCPU1 = new javax.swing.JScrollPane();
        cpuTable1 = new javax.swing.JTable();
        pCPU2 = new javax.swing.JPanel();
        spCPU2 = new javax.swing.JScrollPane();
        cpuTable2 = new javax.swing.JTable();
        upperPanel = new javax.swing.JPanel();
        upperLeftPanel = new javax.swing.JPanel();
        buttonPanel = new javax.swing.JPanel();
        bCargar = new javax.swing.JButton();
        bLimpear = new javax.swing.JButton();
        bEjecutar = new javax.swing.JButton();
        bPaso = new javax.swing.JButton();
        bSiguiente = new javax.swing.JButton();
        bEstadistica = new javax.swing.JButton();
        pProcesosEstadosBPC = new javax.swing.JPanel();
        spProcesosEstads = new javax.swing.JScrollPane();
        procesosEstados = new javax.swing.JTable();
        BPCPanel = new javax.swing.JPanel();
        BPCText1 = new javax.swing.JLabel();
        spBPC1 = new javax.swing.JScrollPane();
        BPC1 = new javax.swing.JList<>();
        BPCText2 = new javax.swing.JLabel();
        spBPC2 = new javax.swing.JScrollPane();
        BPC2 = new javax.swing.JList<>();
        upperRightPanel = new javax.swing.JPanel();
        pMemoriaDisco = new javax.swing.JPanel();
        spMemoria = new javax.swing.JScrollPane();
        memoriaTable = new javax.swing.JTable();
        spDisco = new javax.swing.JScrollPane();
        discoTable = new javax.swing.JTable();
        menuBar = new javax.swing.JMenuBar();
        menuFile = new javax.swing.JMenu();
        menuFileOpen = new javax.swing.JMenuItem();
        menuEdit = new javax.swing.JMenu();
        menuEditConf = new javax.swing.JMenuItem();

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane1.setViewportView(jTable1);

        configDialog.setMinimumSize(new java.awt.Dimension(400, 300));
        configDialog.setPreferredSize(new java.awt.Dimension(400, 300));
        configDialog.setResizable(false);
        configDialog.setSize(new java.awt.Dimension(400, 300));

        labMemoria.setText("Tamaño memoria");

        labMemoriaVirtual.setText("Tamaño memoria virtual");

        labPila.setText("Tamaño pila");

        labAlmacenamiento.setText("Tamaño almacenamiento");

        memoriaTextField.setText("40");

        almacenamientoTextField.setText("512");

        virtualTextField.setText("64");

        pilaTextField.setText("10");

        bGuardarConf.setText("Guardar");
        bGuardarConf.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bGuardarConfActionPerformed(evt);
            }
        });

        bRestablecer.setText("Restablecer");
        bRestablecer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bRestablecerActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout configDialogLayout = new javax.swing.GroupLayout(configDialog.getContentPane());
        configDialog.getContentPane().setLayout(configDialogLayout);
        configDialogLayout.setHorizontalGroup(
            configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(configDialogLayout.createSequentialGroup()
                .addGap(71, 71, 71)
                .addGroup(configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(configDialogLayout.createSequentialGroup()
                        .addComponent(bRestablecer)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(bGuardarConf)
                        .addGap(152, 152, 152))
                    .addGroup(configDialogLayout.createSequentialGroup()
                        .addGroup(configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(labMemoria)
                            .addComponent(labMemoriaVirtual)
                            .addComponent(labAlmacenamiento)
                            .addComponent(labPila))
                        .addGap(18, 18, 18)
                        .addGroup(configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(virtualTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(memoriaTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(almacenamientoTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(pilaTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(112, 112, 112))))
        );

        configDialogLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {almacenamientoTextField, memoriaTextField, pilaTextField, virtualTextField});

        configDialogLayout.setVerticalGroup(
            configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(configDialogLayout.createSequentialGroup()
                .addGap(65, 65, 65)
                .addGroup(configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labMemoria)
                    .addComponent(memoriaTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(labMemoriaVirtual)
                        .addComponent(virtualTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(configDialogLayout.createSequentialGroup()
                        .addGap(40, 40, 40)
                        .addGroup(configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(almacenamientoTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(labAlmacenamiento))))
                .addGap(18, 18, 18)
                .addGroup(configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(pilaTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(labPila))
                .addGap(18, 18, 18)
                .addGroup(configDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(bGuardarConf)
                    .addComponent(bRestablecer))
                .addGap(52, 52, 52))
        );

        configDialogLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {almacenamientoTextField, memoriaTextField, pilaTextField, virtualTextField});

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Proyecto 1");
        setMinimumSize(new java.awt.Dimension(800, 750));
        setSize(new java.awt.Dimension(800, 750));

        lowerPanel.setPreferredSize(new java.awt.Dimension(777, 300));
        lowerPanel.setLayout(new java.awt.BorderLayout());

        pCPU1.setPreferredSize(new java.awt.Dimension(777, 150));

        cpuTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"P1"},
                {"Px"}
            },
            new String [] {
                "CPU 1"
            }
        ));
        spCPU1.setViewportView(cpuTable1);

        javax.swing.GroupLayout pCPU1Layout = new javax.swing.GroupLayout(pCPU1);
        pCPU1.setLayout(pCPU1Layout);
        pCPU1Layout.setHorizontalGroup(
            pCPU1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 777, Short.MAX_VALUE)
            .addGroup(pCPU1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(pCPU1Layout.createSequentialGroup()
                    .addGap(66, 66, 66)
                    .addComponent(spCPU1, javax.swing.GroupLayout.DEFAULT_SIZE, 645, Short.MAX_VALUE)
                    .addGap(66, 66, 66)))
        );
        pCPU1Layout.setVerticalGroup(
            pCPU1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 150, Short.MAX_VALUE)
            .addGroup(pCPU1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(pCPU1Layout.createSequentialGroup()
                    .addGap(14, 14, 14)
                    .addComponent(spCPU1, javax.swing.GroupLayout.DEFAULT_SIZE, 122, Short.MAX_VALUE)
                    .addGap(14, 14, 14)))
        );

        lowerPanel.add(pCPU1, java.awt.BorderLayout.PAGE_START);

        pCPU2.setPreferredSize(new java.awt.Dimension(777, 150));

        cpuTable2.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"P1"},
                {"Px"},
                {null}
            },
            new String [] {
                "CPU 2"
            }
        ));
        spCPU2.setViewportView(cpuTable2);

        javax.swing.GroupLayout pCPU2Layout = new javax.swing.GroupLayout(pCPU2);
        pCPU2.setLayout(pCPU2Layout);
        pCPU2Layout.setHorizontalGroup(
            pCPU2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 777, Short.MAX_VALUE)
            .addGroup(pCPU2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(pCPU2Layout.createSequentialGroup()
                    .addGap(66, 66, 66)
                    .addComponent(spCPU2, javax.swing.GroupLayout.DEFAULT_SIZE, 645, Short.MAX_VALUE)
                    .addGap(66, 66, 66)))
        );
        pCPU2Layout.setVerticalGroup(
            pCPU2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 150, Short.MAX_VALUE)
            .addGroup(pCPU2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(pCPU2Layout.createSequentialGroup()
                    .addGap(14, 14, 14)
                    .addComponent(spCPU2, javax.swing.GroupLayout.DEFAULT_SIZE, 122, Short.MAX_VALUE)
                    .addGap(14, 14, 14)))
        );

        lowerPanel.add(pCPU2, java.awt.BorderLayout.PAGE_END);

        getContentPane().add(lowerPanel, java.awt.BorderLayout.PAGE_END);

        upperPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        upperPanel.setPreferredSize(new java.awt.Dimension(400, 450));
        upperPanel.setLayout(new javax.swing.BoxLayout(upperPanel, javax.swing.BoxLayout.X_AXIS));

        upperLeftPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(255, 255, 255)));
        upperLeftPanel.setMaximumSize(new java.awt.Dimension(500, 900));
        upperLeftPanel.setMinimumSize(new java.awt.Dimension(400, 375));
        upperLeftPanel.setPreferredSize(new java.awt.Dimension(400, 375));
        upperLeftPanel.setLayout(new java.awt.BorderLayout());

        buttonPanel.setMaximumSize(new java.awt.Dimension(400, 120));
        buttonPanel.setMinimumSize(new java.awt.Dimension(400, 75));
        buttonPanel.setPreferredSize(new java.awt.Dimension(400, 75));
        buttonPanel.setLayout(new java.awt.GridBagLayout());

        bCargar.setText("Cargar");
        bCargar.setMaximumSize(new java.awt.Dimension(100, 32));
        bCargar.setMinimumSize(new java.awt.Dimension(100, 32));
        bCargar.setPreferredSize(new java.awt.Dimension(100, 32));
        bCargar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bCargarActionPerformed(evt);
            }
        });
        buttonPanel.add(bCargar, new java.awt.GridBagConstraints());

        bLimpear.setText("Limpiar");
        bLimpear.setMaximumSize(new java.awt.Dimension(100, 32));
        bLimpear.setMinimumSize(new java.awt.Dimension(100, 32));
        bLimpear.setPreferredSize(new java.awt.Dimension(100, 32));
        bLimpear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bLimpearActionPerformed(evt);
            }
        });
        buttonPanel.add(bLimpear, new java.awt.GridBagConstraints());

        bEjecutar.setText("Ejecutar");
        bEjecutar.setEnabled(false);
        bEjecutar.setMaximumSize(new java.awt.Dimension(100, 32));
        bEjecutar.setMinimumSize(new java.awt.Dimension(100, 32));
        bEjecutar.setPreferredSize(new java.awt.Dimension(100, 32));
        bEjecutar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bEjecutarActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        buttonPanel.add(bEjecutar, gridBagConstraints);

        bPaso.setText("Paso a Paso");
        bPaso.setFocusable(false);
        bPaso.setMaximumSize(new java.awt.Dimension(100, 32));
        bPaso.setMinimumSize(new java.awt.Dimension(100, 32));
        bPaso.setPreferredSize(new java.awt.Dimension(100, 32));
        bPaso.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bPasoActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        buttonPanel.add(bPaso, gridBagConstraints);

        bSiguiente.setText("Siguiente");
        bSiguiente.setEnabled(false);
        bSiguiente.setFocusable(false);
        bSiguiente.setMaximumSize(new java.awt.Dimension(100, 32));
        bSiguiente.setMinimumSize(new java.awt.Dimension(100, 32));
        bSiguiente.setPreferredSize(new java.awt.Dimension(100, 32));
        bSiguiente.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bSiguienteActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        buttonPanel.add(bSiguiente, gridBagConstraints);

        bEstadistica.setText("Estadistica");
        bEstadistica.setEnabled(false);
        bEstadistica.setMaximumSize(new java.awt.Dimension(100, 32));
        bEstadistica.setMinimumSize(new java.awt.Dimension(100, 32));
        bEstadistica.setPreferredSize(new java.awt.Dimension(100, 32));
        bEstadistica.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bEstadisticaActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        buttonPanel.add(bEstadistica, gridBagConstraints);

        upperLeftPanel.add(buttonPanel, java.awt.BorderLayout.PAGE_START);

        pProcesosEstadosBPC.setPreferredSize(new java.awt.Dimension(400, 300));
        pProcesosEstadosBPC.setLayout(new java.awt.BorderLayout());

        spProcesosEstads.setPreferredSize(new java.awt.Dimension(200, 60));

        procesosEstados.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null}
            },
            new String [] {
                "Procesos", "Estados"
            }
        ));
        procesosEstados.setPreferredSize(new java.awt.Dimension(200, 80));
        spProcesosEstads.setViewportView(procesosEstados);

        pProcesosEstadosBPC.add(spProcesosEstads, java.awt.BorderLayout.LINE_START);

        BPCPanel.setLayout(new javax.swing.BoxLayout(BPCPanel, javax.swing.BoxLayout.Y_AXIS));

        BPCText1.setText("BPC actual CPU1");
        BPCPanel.add(BPCText1);

        BPC1.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { "PC", "IR", "AC", "ETC" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        spBPC1.setViewportView(BPC1);

        BPCPanel.add(spBPC1);

        BPCText2.setText("BPC actual CPU2");
        BPCPanel.add(BPCText2);

        BPC2.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { "PC", "IR", "AC", "ETC" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        spBPC2.setViewportView(BPC2);

        BPCPanel.add(spBPC2);

        pProcesosEstadosBPC.add(BPCPanel, java.awt.BorderLayout.CENTER);

        upperLeftPanel.add(pProcesosEstadosBPC, java.awt.BorderLayout.CENTER);

        upperPanel.add(upperLeftPanel);

        upperRightPanel.setPreferredSize(new java.awt.Dimension(400, 375));
        upperRightPanel.setLayout(new javax.swing.BoxLayout(upperRightPanel, javax.swing.BoxLayout.Y_AXIS));

        spMemoria.setPreferredSize(new java.awt.Dimension(125, 60));

        memoriaTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"0", null},
                {"1", null},
                {null, null}
            },
            new String [] {
                "Pos", "Valor en memoria"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        spMemoria.setViewportView(memoriaTable);

        spDisco.setPreferredSize(new java.awt.Dimension(125, 60));

        discoTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"0", null},
                {"1", null},
                {null, null}
            },
            new String [] {
                "Pos", "Valor en disco"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        spDisco.setViewportView(discoTable);

        javax.swing.GroupLayout pMemoriaDiscoLayout = new javax.swing.GroupLayout(pMemoriaDisco);
        pMemoriaDisco.setLayout(pMemoriaDiscoLayout);
        pMemoriaDiscoLayout.setHorizontalGroup(
            pMemoriaDiscoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pMemoriaDiscoLayout.createSequentialGroup()
                .addComponent(spMemoria, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(0, 0, 0)
                .addComponent(spDisco, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        pMemoriaDiscoLayout.setVerticalGroup(
            pMemoriaDiscoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pMemoriaDiscoLayout.createSequentialGroup()
                .addGroup(pMemoriaDiscoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(spDisco, javax.swing.GroupLayout.DEFAULT_SIZE, 184, Short.MAX_VALUE)
                    .addComponent(spMemoria, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(0, 0, 0))
        );

        upperRightPanel.add(pMemoriaDisco);

        upperPanel.add(upperRightPanel);

        getContentPane().add(upperPanel, java.awt.BorderLayout.CENTER);

        menuFile.setText("File");

        menuFileOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        menuFileOpen.setText("Cargar Archivo");
        menuFileOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuFileOpenActionPerformed(evt);
            }
        });
        menuFile.add(menuFileOpen);

        menuBar.add(menuFile);

        menuEdit.setText("Edit");

        menuEditConf.setText("Configuración");
        menuEditConf.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuEditConfActionPerformed(evt);
            }
        });
        menuEdit.add(menuEditConf);

        menuBar.add(menuEdit);

        setJMenuBar(menuBar);

        pack();
    }// </editor-fold>//GEN-END:initComponents
  
    /**
     * Toma el valor del registro especificado por "registro_por_tomar" y lo asigna a "AC".
     * @param registro_por_tomar el registro del cual se tomará el valor a asignar a "AC".
     */
    public static void load(String registro_por_tomar) {
        int valor_por_tomar = registros_valores.get(registro_por_tomar);
        registros_valores.put("AC", valor_por_tomar);
    }

    /**
    * Toma el valor actual en "AC" y lo asigna al registro especificado por "registro_por_actualizar".
    * @param registro_por_actualizar el registro al cual se le asignará el valor actual en "AC".
    */
    public static void store(String registro_por_actualizar) {
        registros_valores.put(registro_por_actualizar, registros_valores.get("AC"));
    }
    
    /**
     * Asigna el valor dado por valor_asignado al registro dado por reg_destino
     * @param reg_destino el registro al cual se le asignará un nuevo valor.
     * @param valor_asignado el valor que se asignará al registro especificado.
     */
    public static void mov_valor(String reg_destino, Integer valor_asignado) {
        registros_valores.put(reg_destino, valor_asignado);
    }
      
    /**
     * Asigna el valor tomado del registro reg_origen al registro dado por reg_destino
     * @param reg_destino el registro al cual se le asignará un nuevo valor.
     * @param reg_origen el registro del que se tomara el valor por asignar.
     */
    public static void mov_reg(String reg_destino, String reg_origen) {
        registros_valores.put(reg_destino, registros_valores.get(reg_origen));
    }
    
    /**
     * Toma el valor del registro especificado por "registro_a_sumar" y lo suma al valor actual en "AC".
     * @param registro_a_sumar el registro cuyo valor se sumará al valor actual en "AC".
     */
    public static void add(String registro_a_sumar) {
        int valor_a_sumar = registros_valores.get(registro_a_sumar);
        int nuevo_valor = registros_valores.get("AC") + valor_a_sumar;
        registros_valores.put("AC", nuevo_valor);
    }

    /**
     * Toma el valor del registro especificado por "registro_a_restar" y lo resta al valor actual en "AC".
     * @param registro_a_restar el registro cuyo valor se restará al valor actual en "AC".
     */
    public static void sub(String registro_a_restar) {
        int valor_a_restar = registros_valores.get(registro_a_restar);
        int nuevo_valor = registros_valores.get("AC") - valor_a_restar;
        registros_valores.put("AC", nuevo_valor);
    }

    /**
     * Incrementa el valor dado por registro_a_incrementar
     * @param registro_a_incrementar el registro a incrementar
     */
    public static void inc(String registro_a_incrementar) {
        int nuevo_valor = registros_valores.get(registro_a_incrementar) + 1;
        registros_valores.put(registro_a_incrementar, nuevo_valor);
    }
    
    /**
     * Incrementa el valor al registro AC
     */
    public static void inc(){
        inc("AC");
    }
    
    /**
     * Decrementa el valor dado por registro_a_decrementar
     * @param registro_a_decrementar el registro a decrementar
     */
    public static void dec(String registro_a_decrementar) {
        int nuevo_valor = registros_valores.get(registro_a_decrementar) - 1;
        registros_valores.put(registro_a_decrementar, nuevo_valor);
    }
    
    /**
     * Decrementa el valor al registro AC
     */
    public static void dec(){
        dec("AC");
    }
    
    /**
     * Intercambia los valores entre registro_1 y registro_2
     */
    public static void swap(String registro_1, String registro_2) {
        int t_registro_1 = registros_valores.get(registro_1);
        int t_registro_2 = registros_valores.get(registro_2);
        registros_valores.put(registro_1, t_registro_2);
        registros_valores.put(registro_2, t_registro_1);
    }

    /**
     * Guarda en pila el valor del registro especificado por el parámetro 'registro_a_tomar'.
     * @param registro_a_tomar El nombre del registro cuyo valor se debe guardar en pila.
     */
    public static void push(String registro_a_tomar){
        la_pila.push(registros_valores.get(registro_a_tomar));
    }
    /**
     * Almacena un valor entero en la pila.
     * @param valor_por_almacenar El valor entero a almacenar en la pila.
     */
    public static void push_value(String valor_por_almacenar){
        la_pila.push(Integer.valueOf(valor_por_almacenar));
    }
    
    /**
     * Saca el valor de la pila y lo almacena en reg_destino
     * @param reg_destino registro en el que se almacena el valor de la pila
     */
    public static void pop(String reg_destino){
        registros_valores.put(reg_destino, la_pila.pop());
    }
    
    /**
     * Este método solicita al usuario ingresar un valor numérico entre 0 y 255 para el registro DX.
     * Si el usuario ingresa un valor numérico válido, lo almacena en el registro DX a través del método mov_valor().
     * Si el usuario ingresa un valor no numérico, muestra un mensaje de error en la terminal
     * Si el usuario ingresa un valor numérico fuera del rango válido, muestra un mensaje de error. en la terminal
     */
    public void int09(){
        /*try {
            String input = terminal.getInput();
            int value = Integer.parseInt(input);
            if (value >= 0 && value <= 255) {
                mov_valor("DX", value);
            }
            else {
                terminal.addToOuput("Error: debe ingresar un valor numérico entre 0-255.");
            }
        } catch (NumberFormatException e) {
            terminal.addToOuput("Error: debe ingresar un valor numérico entre 0-255.");
        }*/
    }
    
    public void setEstadoBotones(boolean[] botones_a_setear){
        bCargar.setEnabled(botones_a_setear[0]);
        bEjecutar.setEnabled(botones_a_setear[1]);
        bEstadistica.setEnabled(botones_a_setear[2]);
        bLimpear.setEnabled(botones_a_setear[3]);
        bPaso.setEnabled(botones_a_setear[4]);
        bSiguiente.setEnabled(botones_a_setear[5]);
    }
    
    public void obtenerEstadoBotones(boolean[] botones_a_obtener){
        botones_a_obtener[0] = bCargar.isEnabled();
        botones_a_obtener[1] = bEjecutar.isEnabled();
        botones_a_obtener[2] = bEstadistica.isEnabled();
        botones_a_obtener[3] = bLimpear.isEnabled();
        botones_a_obtener[4] = bPaso.isEnabled();
        botones_a_obtener[5] = bSiguiente.isEnabled(); 
    }
    
    public void cambiarEstadoComponentes(boolean nuevo_estado) {
        cambiarEstadoComponentes(this, nuevo_estado);
    }  
    
    public void cambiarEstadoComponentes(Container container, boolean nuevo_estado) {

        Component[] componentes = container.getComponents();
        for (Component componente : componentes) {
            if (componente instanceof Container) {
                cambiarEstadoComponentes((Container) componente, nuevo_estado);
            }
            if (!(componente.getClass().toString().equals("class model.terminal"))) {
                componente.setEnabled(nuevo_estado);
            }
        }
    }

    /**
     * Compara dos valores almacenados en registros y establece 
     *  una variable de bandera según el resultado de la comparación.
     * @param registro_1 El nombre del primer registro a comparar.
     * @param registro_2 El nombre del segundo registro a comparar.
     */
    public static void cmp(String registro_1, String registro_2) {
        bandera_cmp = registros_valores.get(registro_1) == registros_valores.get(registro_2);
    }
    
    /* ---------------------------------------------------------------------- */
    /**
    * Convierte un número entero en su representación binaria de 8 bits,
    * teniendo en cuenta el signo del número.
    * @param num El número entero a convertir.
    * @return La representación binaria de 8 bits del número.
    */
    public static String intToBinary8(int num) {
        String binaryString = Integer.toBinaryString(Math.abs(num)); // convertir el valor absoluto a binario
        binaryString = String.format("%8s", binaryString).replace(' ', '0'); // completar con ceros a la izquierda
        if (num < 0) { // si el número es negativo, cambiar el bit de signo
            binaryString = "1" + binaryString.substring(1);
        } else {
            binaryString = "0" + binaryString.substring(1);
        }
        return binaryString;
    }

    /**
     * Toma una lista de cadenas de una línea de código y usa un mapa de operaciones y un mapa de registros ya definidos, 
     * y devuelve una cadena que representa la línea de código en binario.
     * 
     * @param linea La lista de cadenas que representa la línea de código a parsear.
     * @return Una cadena que representa la línea de código en binario.
     */
    public static String parseLine(List<String> linea) {
        String operador = linea.get(0);
        String registro = linea.get(1);
        String valor = "00000000";
        if (linea.size() == 3) {
            int numero = Integer.parseInt(linea.get(2));
            valor = intToBinary8(numero);
        }
        //String codigo = operaciones.get(operador);
        //String registroBin = registros.get(registro);
        return "";// codigo + " " + registroBin + " " + valor;
    }

    /**
    * Busca un segmento de memoria no utilizado de n líneas consecutivas, 
    * empezando por el índice inicial especificado.
    * 
    * @param indiceInicial El índice inicial a partir del cual buscar.
    * @return Un array de dos elementos que contiene el índice inicial y 
    * final del segmento encontrado, o un array con [-1, -1] si no se encontró ninguno.
    */
    private static int[] buscarSegmentoUsado(int indiceInicial) {
        int indiceActual = indiceInicial;
        while (indiceActual < memoria.length && memoria[indiceActual].isEmpty()) {
            indiceActual++;
        }
        if (indiceActual == memoria.length) {
            // No se encontró ningún segmento con información
            return new int[] {-1, -1};
        }
        // Se encontró un segmento con información
        int indiceFinal = indiceActual;
        while (indiceFinal < memoria.length && !memoria[indiceFinal].isEmpty()) {
            indiceFinal++;
        }
        return new int[] {indiceActual, indiceFinal-1};
    }
    /**
     * Busca el índice del primer segmento de memoria que contenga información.
     * @return El índice del segmento inicial si se encuentra uno, de lo contrario -1.
     */
    private static int buscarSegmentoInicial() {
        if (!archivo_cargado1 && !archivo_cargado2){
            return -1;
        }
        int indiceActual = 0;
        while (indiceActual < memoria.length && memoria[indiceActual].isEmpty()) {
            indiceActual++;
        }
        if (indiceActual == memoria.length) {
            return -1; // No se encontró ningún segmento con información
        }
        return indiceActual;
    }

    private void limpearMemoria() {
        memoria = new ArrayList[n_memoria];
        for (int i = 0; i < n_memoria; i++) {
            memoria[i] = new ArrayList<>(); 
        } 
    }

    private void limpearPila() {
        la_pila = new pila(n_pila);
    }

    /**
    * Verifica si alguna de las listas en memoria_a_verificar contiene elementos.
    *
    * @param memoria_a_verificar Una lista de listas de strings que representa la memoria a verificar.
    * @return Verdadero si al menos una de las listas contiene elementos, falso de lo contrario.
    */
    private boolean tieneDatos(List<String>[] memoria_a_verificar){
        for (List<String> l: memoria_a_verificar){
            if (!l.isEmpty()) return true;
        }
        return false;
    }

    private void ejecutarPorIndice(int i){
        boolean banderaSalto = false;
        if (memoria[i] == null || memoria[i].isEmpty() || i < 0 || i > n_memoria){
            bandera_error = true;
            limpearMemoria();
            throw new RuntimeException("Error: fuera de rango.");
        }
        switch (memoria[i].get(0)){
            case "MOV":
                if (esEntero(memoria[i].get(2))){
                    mov_valor(memoria[i].get(1), Integer.valueOf(memoria[i].get(2)));
                } else {
                    mov_reg(memoria[i].get(1), memoria[i].get(2));
                }
                break;
            case "LOAD":
                load(memoria[i].get(1));
                break;
            case "STORE":
                store(memoria[i].get(1));
                break;
            case "ADD":
                add(memoria[i].get(1));
                break;
            case "SUB":
                sub(memoria[i].get(1));
                break;
            case "INC":
                if (memoria[i].size() == 1){
                    inc();
                } else {
                    inc(memoria[i].get(1));
                }
                break;
            case "DEC":
                if (memoria[i].size() == 1){
                    dec();
                } else {
                    dec(memoria[i].get(1));
                }
                break;
            case "SWAP":
                swap(memoria[i].get(1), memoria[i].get(2));
                break;
            case "INT":
                switch (memoria[i].get(1)) {
                    case "20H": // Finaliza el programa 
                        bandera_interrupcion = true;
                        break;
                    case "10H": // Imprime en pantalla el valor del DX
                        terminal.addToOuput("DX: " + String.valueOf(registros_valores.get("DX")));
                        break;
                    case "09H": // Entrada del teclado (solo numérico 0-255), el valor se guarda en el DX, finaliza con un ENTER
                        obtenerEstadoBotones(estado_botones);
                        cambiarEstadoComponentes(this, false);
                        upperPanel.setEnabled(true);
                        terminal.activarField();
                        esperando = true;
                        break;
                    case "21H": // Será utilizado para manejo de archivos.
                        break;
                    case "3CH":
                        // Manejar la interrupción 3CH
                        // ...
                        break;
                    case "3DH":
                        // Manejar la interrupción 3DH
                        // ...
                        break;
                    case "4DH":
                        // Manejar la interrupción 4DH
                        // ...
                        break;
                    case "40H":
                        // Manejar la interrupción 40H
                        // ...
                        break;
                    case "41H":
                        // Manejar la interrupción 41H
                        // ...
                        break;
                }
                break;
            case "CMP":
                cmp(memoria[i].get(1), memoria[i].get(2));
                break;
            case "PUSH":
                push(memoria[i].get(1));
                break;
            case "POP":
                pop(memoria[i].get(1));
                break;
            case "JMP":
                banderaSalto = true;
                break;
            case "JE":
                if (bandera_cmp){
                    banderaSalto = true;
                } else {
                    banderaSalto = false;
                }
                break;
            case "JNE":
                if (!bandera_cmp){
                    banderaSalto = true;
                } else {
                    banderaSalto = false;
                }
                break;
            case "PARAM":
                for (int contador = 1; contador < memoria[i].size(); contador++){
                    push_value(memoria[i].get(contador));
                }
                break;
        }
        if (!banderaSalto){
            siguienteInstruccion++;
        } else {
            int salto = Integer.valueOf(memoria[i].get(1));
            if (salto < 0){
                siguienteInstruccion += Integer.valueOf(memoria[i].get(1)) - 1;
            } else{
                siguienteInstruccion += Integer.valueOf(memoria[i].get(1)) + 1; 
            }
        }
    }
    
    private void bEjecutarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bEjecutarActionPerformed
        bandera_interrupcion = false;
        if (!esperando){
            siguienteInstruccion = buscarSegmentoInicial();
            bandera_error = false;
        } else{
            esperando = false;
        }
        while (true){
            try {
                System.out.print("Memoria: " + memoria[siguienteInstruccion]); // debug
                if (bandera_interrupcion){
                    break;
                }
                ejecutarPorIndice(siguienteInstruccion);
                System.out.println(registros_valores); // debug 
            } catch(RuntimeException e){
                terminal.addToOuput(e.getMessage());
                break;
            }
            if (esperando){
                break;
            }

        }
        if (esperando){
            terminal.addToOuput("Ingrese un valor: ");
        } else{   
            if (bandera_error){
                terminal.addToOuput("Ejecución finalizada sin exito.");
            } else{ 
                terminal.addToOuput("Ejecución finalizada.");
            }
        }
    }//GEN-LAST:event_bEjecutarActionPerformed

    private void menuFileOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuFileOpenActionPerformed
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new File(System.getProperty("user.home") + "/Desktop"));
        chooser.setAcceptAllFileFilterUsed(false); // Deshabilitar el filtro predeterminado
        FileNameExtensionFilter filter = new FileNameExtensionFilter("Archivos ASM", "asm");
        chooser.setFileFilter(filter);
        int result = chooser.showOpenDialog(null);
        if (result == JFileChooser.APPROVE_OPTION) {
            String path = chooser.getSelectedFile().getPath();
            terminal.addToOuput("Archivo  seleccionado: " + path);

            try {
                List<String>[] temp_memoria = memoria.clone(); // Clonamos memoria a una memoria temporal
                temp_memoria = leerArchivo(path, temp_memoria, false); // Se lee arhivo y se asigna a la memoria temporal
                if (memoria != temp_memoria && tieneDatos(temp_memoria)) { // Se verifica que las memorias sean diferentes y no esten vacias
                    memoria = temp_memoria.clone();
                    terminal.addToOuput("Archivo cargado exitosamente");
                    archivo_cargado1 = true;
                }
                
                setButton(true, bEjecutar);
                setButton(true, bPaso);
            } catch (RuntimeException e) {
                terminal.addToOuput(e.getMessage());
            }
        }
    }//GEN-LAST:event_menuFileOpenActionPerformed

    private void bLimpearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bLimpearActionPerformed
        int respuesta = JOptionPane.showConfirmDialog(null, "¿Estás seguro que quieres limpiar el programa?", "Confirmación", JOptionPane.YES_NO_OPTION);
        if (respuesta == JOptionPane.YES_OPTION) {
            limpearMemoria();
            terminal.cleanTerminal();
            registros_valores = new HashMap<String, Integer>() {{ // Limpeamos memoria
                put("AC", 0); put("AX", 0); put("BX", 0); put("CX", 0); put("DX", 0);
            }};
            la_pila = new pila(n_pila);
            
            setButton(false, bEjecutar);
            setButton(false, bPaso);
            setButton(false, bEstadistica);
            setButton(false, bSiguiente);
        } 
    }//GEN-LAST:event_bLimpearActionPerformed

    private void bEstadisticaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bEstadisticaActionPerformed
        
    }//GEN-LAST:event_bEstadisticaActionPerformed

    private void bCargarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bCargarActionPerformed
        menuFileOpenActionPerformed(null);
    }//GEN-LAST:event_bCargarActionPerformed

    private void bPasoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bPasoActionPerformed
       bSiguienteActionPerformed(null);
    }//GEN-LAST:event_bPasoActionPerformed
   
    public static void centerDialog(JDialog aDialog){
        Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize();
        int pointX = (int)((dimension.getWidth() - aDialog.getWidth()) / 2);
        int pointY = (int)((dimension.getHeight() - aDialog.getHeight()) / 2);
        aDialog.setLocation(pointX, pointY);
    }
    
    private void menuEditConfActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuEditConfActionPerformed
        this.setEnabled(false);
        
        this.configDialog.setVisible(true);
        this.configDialog.setEnabled(true);
        centerDialog(configDialog);
        this.memoriaTextField.setText(String.valueOf(this.n_memoria));
        this.virtualTextField.setText(String.valueOf(this.n_virtual));
        this.pilaTextField.setText(String.valueOf(this.n_pila));
        this.almacenamientoTextField.setText(String.valueOf(this.n_almacenamiento));
    }//GEN-LAST:event_menuEditConfActionPerformed
    
    private void focusMainGUI() {
        this.setEnabled(true); 
        this.toFront(); 
        this.requestFocus();
    }
    
    private void bGuardarConfActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bGuardarConfActionPerformed
        try {
            
            int n_v = Integer.parseInt(this.virtualTextField.getText());
            int n_a = Integer.parseInt(this.almacenamientoTextField.getText());
            int n_m = Integer.parseInt(this.memoriaTextField.getText());
            int n_p = Integer.parseInt(this.pilaTextField.getText());
            
            if (n_v >= 1 && n_a >= 1 && n_m >= 1 && n_v >= 1 && n_p >= 1){
                this.n_virtual = n_v;
                this.n_almacenamiento = n_a;
                this.n_memoria = n_m;
                this.n_pila = n_p;

                this.configDialog.dispose();
                this.terminal.addToOuput("Configuración guardada con exito.");
                focusMainGUI();
                limpearMemoria();
                limpearPila();

                registros_valores = new HashMap<String, Integer>() {{ // Limpeamos memoria
                    put("AC", 0); put("AX", 0); put("BX", 0); put("CX", 0); put("DX", 0);
                }};
            } else {
                throw new RuntimeException("Error: los valores para la configuración deben enteros mayores a 1.");
            }
        } catch (Exception e) {
            this.terminal.addToOuput("Error de valores en configuración.");
        }
    }//GEN-LAST:event_bGuardarConfActionPerformed

    private void bRestablecerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bRestablecerActionPerformed
        this.n_virtual = valores_defecto[0];
        this.n_almacenamiento = valores_defecto[1];
        this.n_memoria =  valores_defecto[2];
        this.n_pila =  valores_defecto[3];
        this.configDialog.dispose();
        this.terminal.addToOuput("Configuración restablecida con exito.");
        focusMainGUI();
        limpearMemoria();
        limpearPila();
        registros_valores = new HashMap<String, Integer>() {{ // Limpeamos memoria
            put("AC", 0); put("AX", 0); put("BX", 0); put("CX", 0); put("DX", 0);
        }};
    }//GEN-LAST:event_bRestablecerActionPerformed

    private void bSiguienteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bSiguienteActionPerformed
        bandera_interrupcion = false;
        if (!esperando && !bandera_paso){
            siguienteInstruccion = buscarSegmentoInicial();
            bandera_error = false;
        } else{
            esperando = false;
        }
        if (!bandera_paso){
            bandera_paso = true;
            obtenerEstadoBotones(estado_botones_paso);
            bCargar.setEnabled(false);
            bEjecutar.setEnabled(false);
            bEstadistica.setEnabled(false);
            bLimpear.setEnabled(false);
            bPaso.setEnabled(false);
            bSiguiente.setEnabled(true);
            terminal.addToOuput("Ejecución paso a paso inicida.");
        }
        
        try {
            System.out.print("Memoria: " + memoria[siguienteInstruccion] + " | bandera_interrupcion " + bandera_interrupcion); // debug 
            ejecutarPorIndice(siguienteInstruccion);
            System.out.println(registros_valores); // borrar 
        } catch(RuntimeException e){
            terminal.addToOuput(e.getMessage());
        }
        
        if (esperando){
            terminal.addToOuput("Instrucción \"" + memoria[siguienteInstruccion-1] + "\" ejecutada con exito.\n");
            terminal.addToOuput("> Ingrese un valor: ");
        } else if (!bandera_paso || bandera_interrupcion){
            bandera_paso = false;
            bandera_interrupcion = false;
            setEstadoBotones(estado_botones_paso);
            if (bandera_error){
                terminal.addToOuput("\n> Ejecución paso a paso finalizada sin exito.");
            } else{ 
                terminal.addToOuput("\n> Ejecución paso a paso finalizada.");
            }
        } else{
            if (!esperando){
                terminal.addToOuput("Instrucción \"" + memoria[siguienteInstruccion-1] + "\" ejecutada con exito.");
            }
        }
    }//GEN-LAST:event_bSiguienteActionPerformed
    
    public void setButton(boolean nuevo_estado, JButton boton){
        //boton.setVisible(nuevo_estado);
        boton.setEnabled(nuevo_estado);
        boton.setFocusable(nuevo_estado);
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            /*for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("WindowsLookAndFeel".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }*/
            UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new Main().setVisible(true);
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JList<String> BPC1;
    private javax.swing.JList<String> BPC2;
    private javax.swing.JPanel BPCPanel;
    private javax.swing.JLabel BPCText1;
    private javax.swing.JLabel BPCText2;
    private javax.swing.JTextField almacenamientoTextField;
    private javax.swing.JButton bCargar;
    private javax.swing.JButton bEjecutar;
    private javax.swing.JButton bEstadistica;
    private javax.swing.JButton bGuardarConf;
    private javax.swing.JButton bLimpear;
    private javax.swing.JButton bPaso;
    private javax.swing.JButton bRestablecer;
    private javax.swing.JButton bSiguiente;
    private javax.swing.JPanel buttonPanel;
    private javax.swing.JDialog configDialog;
    private javax.swing.JTable cpuTable1;
    private javax.swing.JTable cpuTable2;
    private javax.swing.JTable discoTable;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    private javax.swing.JLabel labAlmacenamiento;
    private javax.swing.JLabel labMemoria;
    private javax.swing.JLabel labMemoriaVirtual;
    private javax.swing.JLabel labPila;
    private javax.swing.JPanel lowerPanel;
    private javax.swing.JTable memoriaTable;
    private javax.swing.JTextField memoriaTextField;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JMenu menuEdit;
    private javax.swing.JMenuItem menuEditConf;
    private javax.swing.JMenu menuFile;
    private javax.swing.JMenuItem menuFileOpen;
    private javax.swing.JPanel pCPU1;
    private javax.swing.JPanel pCPU2;
    private javax.swing.JPanel pMemoriaDisco;
    private javax.swing.JPanel pProcesosEstadosBPC;
    private javax.swing.JTextField pilaTextField;
    private javax.swing.JTable procesosEstados;
    private javax.swing.JScrollPane spBPC1;
    private javax.swing.JScrollPane spBPC2;
    private javax.swing.JScrollPane spCPU1;
    private javax.swing.JScrollPane spCPU2;
    private javax.swing.JScrollPane spDisco;
    private javax.swing.JScrollPane spMemoria;
    private javax.swing.JScrollPane spProcesosEstads;
    private javax.swing.JPanel upperLeftPanel;
    private javax.swing.JPanel upperPanel;
    private javax.swing.JPanel upperRightPanel;
    private javax.swing.JTextField virtualTextField;
    // End of variables declaration//GEN-END:variables
}
